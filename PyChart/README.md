# PyChart
PyChart - это фреймворк для создания приложений, строящих json-файл блок-схемы по коду для сайта [block-diagram-redactor](https://programforyou.ru/block-diagram-redactor"block-diagram-redactor").
- **Разделение ответственности:** вам не нужно решать задачу построения блок-схемы - необходимо реализовать только моменты, которые непосредственно связаны с языком программирования.
- **Портативность:** PyChart может использоваться локально в вашем проекте, не требуя установки никаких сторонних пакетов.
## Установка / Использование
Для локального использования в проекте без установки, имеющего такую структуру:
```
  project/
		libs/
				PyChart/
		app.py
```
Использование в **app.py:**

```python
import libs.PyChart.__init__ as PyChart
```
Для локального использования в проекте c  установкой переходим в папку PyChart и пишем:
```
pip install -e .
```
Использование в **app.py:**
```python
import PyChart
```
## Документация
PyChart состоит из 3-х компонентов:
- PseudoCode - класс, преобразующий реальный код в абстрактный, лишенный каких-либо конкретных операторов из языков программирования. Например: if, else, print(), int().
- Preprocessor - класс, создающий дерево кода без ненужных конструкций, таких как комментарии и т.п.
- BlockDiagram - класс, который непосредственно строит блок-схему по дереву кода.
###  Простой пример
```python
	from LangPreprocessor import *
	from LangBlockDiagram import *
	from LangPseudoCode import *

	f = open('path', encoding='utf-8') # необязательно файл - это может быть список строк.
	p = LangPreprocessor(f)
	programs_list = p.get_programs_list()
	diagram = LangBlockDiagram.build_from_programs_list(programs_list, LangPseudoCode)
```
### LangPseudoCode
В этом классе необходимо реализовать только статический метод **to_pseudocode**, который преобразует реальный код в абстрактный. На вход поступает многострочная строка, на выход - тоже многострочная строка. **Ни в коем случае не удаляйте символ "\n"**.
```python
from PyChart import PseudoCode
class LangPseudoCode(PseudoCode):
		@staticmethod
		def to_pseudocode(lines: str) -> str:
			lines = lines.split('\n')  # разбиваем строку на линии
			for line in lines:
				line = line # делаем что-то с линией
			return ''.join(lines) # возвращаем строку
```
### LangBlockDiagram
Этот класс строит блок-схему. Наследуемся от **BlockDiagram** и реализуем следующие статические методы:
 **_get_struct_type** - метод принимает линию кода и возвращает строку с названием типа. Метод должен возвращать только эти типы:
 - if - блок условия
 - else - блок иначе
 - elif - блок иначе если
 - loop - цикл while, for, foreach
 - function - функция или метод
 - output - функции типа print(), console.log и т.д. **return сюда не подходит - его следует определить как блок**
 - block - все что не входит в предыдущие типы.
	Если типа какой-либо конструкции яп нет в списке, тогда преобразуйте их или запретите использовать оные конструкции. При отсутствии подходящего типа следует определить линию как 'block'.
```python
@staticmethod
    def _get_struct_type(line: str) -> str:
		# определяем тип, допустим, function
        return 'function' # возвращаем тип
```
 **_get_bd_type_of_line** - метод принимает линию кода и возвращает строку с названием типа, который определяется сайтом редактора. Метод должен возвращать только эти типы: 
 - Условие - любой блок условия(в том числе 'else if') или цикл while
 - none - блок, который не используется в блок схеме, но подразумевается его наличие. **Обычно таким блоком является else**.
 - Цикл for - к нему относится и foreach
 - Ввод / вывод - print(), console.log() и т.п.
 - Начало / конец - return
 - Блок - все, что не предыдущие типы
```python
    def _get_bd_type_of_line(line: str) -> str:
        # допустим, что тип - 'Блок'
		return 'Блок'
```
### LangPreprocessor
**Необязательно использовать реализацию Preprocessor, как показано далее. Возможно, будет удобннее написать свой класс, реализующий только метод get_programs_list**. Наследуемся от **Preprocessor** и реализуем следующие методы:

**_parse** - метод добавляет  в self._parsed_code все линии,  удаляя комментарии из них. Также он преобразует классы в список функции, а однострочные выражения в многострочные.
```python
	def _parse(self) -> list:
		for i in self._file:
			# удаляем комментарии и добавлем линию в self._parsed_code
			self._parsed_code.append(i)
```
 **_get_serealized_code** - метод создает массив, в котором строка - это обычная линия кода(например print(2)), а словарь - управляющая структура и тело, где ключ является управляющей структурой, а значение - ее телом. **Метод не должен изменять входящий массив**.
 ```python
def _get_serealized_code(self, code: list) -> list:
        """
        метод создает дерево кода, например:
		вход:
		if (n == 1){
			n+=2
			print(n)
		}
		выход:
		[{'if (n == 1)': ['n+=2', print(n)']}]
        """
```
 **_cut_functions** -  метод удаляет все фунцкии из self._serealized-code и возвращает [ {имя_функции: тело_функции} ]. **Метод должен изменять входящий массив**.
 ```python
def _cut_functions(self, serealized_list):
           # return  list: [ { fun-name: fun_body } ]
```
**_get_function_name** - принимает линию кода и возвращает имя функции или пустую строку, если объевления функции нет.

**_find_all_veribles**  принимает дерево или список кода( [{'if (n == 1)': ['n+=2', print(n)']}] или ['n+=2', print(n)'] ) и возвращает список всех переменных. **Метод не должен изменять входящий массив**.

**_get_fun_args** - принимает линию кода и возвращает аргументы функции или [], если объевления функции нет.

**get_programs_list** - **если вам не нужна другая реализация, не имплементируйте этот метод** .он должен возвращать список солварей как, {'code': тело функции или процедурный код, 'name': имя функции или 'main', 'variables': переменные программы}). **Если нет функции main, тогда добавляем все линии процедурного кода**.